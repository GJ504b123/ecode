# 两数之和

题目链接:https://leetcode.cn/problems/two-sum/

leetcode编号no.1，算是无数尝试学习算法的人迈出的第一步，本身这道题目在力扣上标记为简单，所以即使是最简单的暴力算法，时间复杂度来到O(n^2)也可以轻松拿捏.

以go语言为例这里展示两种做法

> 暴力枚举

```
func twoSum(nums []int,target int)[]int{
    result:=make([]int,2)
    for i:=0;i<len(nums);i++{
        for j:=i+1;j<len(nums);j++{
            if nums[i]+nums[j]==target{
                result[0]=i
                result[1]=j
                return result
            }
        }
    }
    return nil
}
```

然后这里提供一种使用散列表(HashMap)的解决方案，这种方案摈弃了内层循环，将其替换为使用map寻找target-nums[i]的元素(基于map的查询时间复杂度是常数级的)，这样大大提高了查询的效率，时间复杂度成功下降到了O(n)

> 引入hash表

```
func twoSum(nums []int, target int) []int {
	result := make([]int, 0)
	map_now := make(map[int]int)
	for i := 0; i < len(nums); i++ {
		value, ok := map_now[target-nums[i]]
		if ok {
			result = append(result, i)
			result = append(result, value)
			return result
		}
		map_now[nums[i]] = i
	}

	return nil
}
```

